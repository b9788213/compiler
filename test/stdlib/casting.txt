fn atoi(s):
     asm
     "xor rax, rax"
     "xor rcx, rcx"
     "movzx rdx, byte [rdi]"
     "cmp dl, '-'"
     "je .prepare_negative"
     "cmp dl, '+'"
     "jne .atoi_loop"
     "inc rcx"
     "jmp .atoi_loop"
     ".prepare_negative:"
     "inc rcx"
     ".neg_loop:"
     "movzx rdx, byte [rdi + rcx]"
     "test dl, dl"
     "jz .apply_neg"
     "cmp dl, '0'"
     "jl .apply_neg"
     "cmp dl, '9'"
     "jg .apply_neg"
     "sub dl, '0'"
     "imul rax, 10"
     "add rax, rdx"
     "inc rcx"
     "jmp .neg_loop"
     ".apply_neg:"
     "neg rax"
     "jmp .exit"
     ".atoi_loop:"
     "movzx rdx, byte [rdi + rcx]"
     "test dl, dl"
     "jz .exit"
     "cmp dl, '0'"
     "jl .exit"
     "cmp dl, '9'"
     "jg .exit"
     "sub dl, '0'"
     "imul rax, 10"
     "add rax, rdx"
     "inc rcx"
     "jmp .atoi_loop"
     asm

fn itoa(i):
     asm
     "push rdi"
     "mov rdi, 4096"
     "call alloc "
     "pop rdi"
     "mov r8, rax"
     "mov r12, rax"
     "mov rax, rdi"
     "mov rbx, 10"
     "xor rcx, rcx"
     "cmp rax, 0"
     "jge .is_zero"
     "neg rax"
     "mov byte [r8], '-'"
     "inc r8"
     ".is_zero:"
     "test rax, rax"
     "jnz .loop"
     "mov rdx, '0'"
     "push rdx"
     "inc rcx"
     "jmp .write_to_buffer"
     ".loop:"
     "test rax, rax"
     "jz .write_to_buffer"
     "cqo"
     "idiv rbx"
     "add rdx, '0'"
     "push rdx"
     "inc rcx"
     "jmp .loop"
     ".write_to_buffer:"
     "test rcx, rcx"
     "jz .done"
     "pop rdx"
     "mov [r8], dl"
     "inc r8"
     "dec rcx"
     "jmp .write_to_buffer"
     ".done:"
     "mov byte [r8], 0"
     "mov rax, r12"
     "jmp .exit"
     asm