fn atoi(s):
    asm "xor rax, rax"
    asm "xor rcx, rcx"
    asm "movzx rdx, byte [rdi]"
    asm "cmp dl, '-'"
    asm "je .prepare_negative"
    asm "cmp dl, '+'"
    asm "jne .atoi_loop"
    asm "inc rcx"
    asm "jmp .atoi_loop"
    asm ".prepare_negative:"
    asm "inc rcx"
    asm ".neg_loop:"
    asm "movzx rdx, byte [rdi + rcx]"
    asm "test dl, dl"
    asm "jz .apply_neg"
    asm "cmp dl, '0'"
    asm "jl .apply_neg"
    asm "cmp dl, '9'"
    asm "jg .apply_neg"
    asm "sub dl, '0'"
    asm "imul rax, 10"
    asm "add rax, rdx"
    asm "inc rcx"
    asm "jmp .neg_loop"
    asm ".apply_neg:"
    asm "neg rax"
    asm "jmp .exit"
    asm ".atoi_loop:"
    asm "movzx rdx, byte [rdi + rcx]"
    asm "test dl, dl"
    asm "jz .exit"
    asm "cmp dl, '0'"
    asm "jl .exit"
    asm "cmp dl, '9'"
    asm "jg .exit"
    asm "sub dl, '0'"
    asm "imul rax, 10"
    asm "add rax, rdx"
    asm "inc rcx"
    asm "jmp .atoi_loop"

fn itoa(i):
    asm "push rdi"
    asm "mov rdi, 4096"
    asm "call alloc "
    asm "pop rdi"
    asm " mov r8, rax"
    asm " mov r12, rax"
    asm " mov rax, rdi"
    asm " mov rbx, 10"
    asm " xor rcx, rcx"
    asm " cmp rax, 0"
    asm "jge .is_zero"
    asm "neg rax"
    asm "mov byte [r8], '-'"
    asm "inc r8"
    asm ".is_zero:"
    asm "test rax, rax"
    asm "jnz .loop"
    asm "mov rdx, '0'"
    asm "push rdx"
    asm "inc rcx"
    asm "jmp .write_to_buffer"
    asm ".loop:"
    asm "test rax, rax"
    asm "jz .write_to_buffer"
    asm "cqo"
    asm "idiv rbx"
    asm "add rdx, '0'"
    asm "push rdx"
    asm "inc rcx"
    asm "jmp .loop"
    asm ".write_to_buffer:"
    asm "test rcx, rcx"
    asm "jz .done"
    asm "pop rdx"
    asm "mov [r8], dl"
    asm "inc r8"
    asm "dec rcx"
    asm "jmp .write_to_buffer"
    asm ".done:"
    asm "mov byte [r8], 0"
    asm "mov rax, r12"
    asm "jmp .exit"